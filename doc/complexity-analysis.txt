https://www.youtube.com/watch?v=OQi4n8EKRD8 

quick_sort(l,r) {
    int p = partition(l,r); //O(n)
    quick_sort(l, p);//T(n/2)
    quick_sort(p+1, r);//T(n/2)
}
T(n) = 2T(n/2) + O(n) --> Time O(nlgn) 
space O(logn) because recursive depth, after lgn = 1. in every recursive function
we did not allocation new space, we only have O(1) for p, so it would be 
O(1) * lgn->O(lgn)

merge_sort(l,r) {
    m = l + (r -l) / 2;
    merge_sort(a, l, m); //T(n/2)
    merge_sort(a, m + 1, r);//T(n/2)
    merge(a, l, m, r); //O(n), here needs additional space when after merge 
    //for temp useage
}
T(n) = 2*T(n/2) + O(n)    Time:O(nlogn)   Space: O(n + logn) merge_sort

InOrder_visit(node){
  InOrder_visit(node.left);//T(n/2)
  visit(node); //O(1)
  InOrder_visit(node.right);//T(n/2)
}

combination(d, s) { //depth, start
   if d == c return func();
   for i in (s, n) {
      combination(d + 1, i + 1);
   }
}
T(n) = T(n-1)+T(n-2)+…+T(1), all in for loop
Space: O(1) * n = O(n) 

permutation(d, used) {// used means used set
    if d == n return func();
    for i in (0, n) {
        for i not in used continue;
        used.add(i);
        permutation(d+1, used);
        used.remove(i);
    }
}
Time: T(n) = n * T(n-1)
Space: O(1)  * n + n = O(n) 
    Equation                        Time    Space       Examples
T(n) = 2*T(n/2) + O(n)          O(nlogn)    O(logn)     quick_sort
T(n) = 2*T(n/2) + O(n)          O(nlogn)    O(n + logn) merge_sort
T(n) = T(n/2) + O(1)            O(logn)     O(logn)     Binary search
T(n) = 2*T(n/2) + O(1)          O(n)        O(logn)     Inorder Binary tree visit
T(n) = T(n-1) + O(1)            O(n)        O(n)        Binary tree traversal visit only have left
T(n) = T(n-1) + O(n)            O(n^2)      O(n)        quick_sort(worst case)
T(n) = n * T(n-1)               O(n!)       O(n)        permutation
T(n) = T(n-1)+T(n-2)+…+T(1)     O(2^n)      O(n)        combination

DP with memorization
Time: number of subproblems time * exclusive time
Space: max depth * space

def fib(n):
  if n < 1: return 1
  if m[n]: return m[n]
  m[n] = fib(n - 1) + fib(n - 2)
  return m[n]

n subproblems fib(0), fib(1), …, fib(n).each sub problem takes O(1) to solve
Time complexity: O(n)
Space complexity: O(n)(array) + O(n)(n) * O(1) = O(n)

741 Cherry Pick
dp(x1, y1, x2):
 if min(x1, y1, x2) < 0: return 0
 if m[x1][y1][x2]: return m[x1][y1][x2]
 ans = max(dp(x1 - 1, y1, x2 - 1), 
           dp(x1, y1 - 1, x2),
           dp(x1, y1 - 1, x2 - 1), 
           dp(x1 - 1, y1, x2))
 m[x1][y1][x2] = ans
 return m[x1][y1][x2]

there are n^3 subproblems, each subproblem takes O(1) to solve
Max recursion depth O(n)
Time: O(n^3)
Space: O(n^3) + O(n) * O(1) = O(n^3)

321 Burst Balloons
dp(i, j):
 if m[i][j]: return m[i][j]
 for k in range(i, j + 1):
   ans = max(ans, dp(i, k - 1) + C + dp(k + 1, j))
 m[i][j] = ans
 return m[i][j]

 dp(0, n), there are n^2 subproblems dp(0, 0), dp(0, 1), …, dp(n-1, n)
 each subproblem takes O(n) to solve

Max recursion depth <= O(n)
Time complexity: O(n^2) * O(n) = O(n^3)
Space complexity: O(n^2) + O(n) * O(1) = O(n^2)


please take a look at graph in Complexity_Cheatsheet.pdf
< 10: O(n!) permutation
< 15: O(2^n) combination
< 50: O(n^4) DP
< 200: O(n^3) DP, all pairs shortest path
< 1,000: O(n^2) DP, all pairs, dense graph
< 1,000,000: O(nlogn), sorting-based (greedy), heap, divide & conquer
< 1,000,000: O(n), DP, graph traversal / topological sorting (V+E), tree traversal
< INT_MAX: O(sqrt(n)), prime, square sum
< INT_MAX: O(logn), binary search
< INT_MAX: O(1) Math

