package hatecode._0001_0999;
import java.util.*;
public class _924MinimizeMalwareSpread {
    /*
     * 924. Minimize Malware Spread In a network of nodes, each node i is directly
     * connected to another node j if and only if graph[i][j] = 1.
     * 
     * Some nodes initial are initially infected by malware. Whenever two nodes are
     * directly connected and at least one of those two nodes is infected by
     * malware, both nodes will be infected by malware. This spread of malware will
     * continue until no more nodes can be infected in this manner.
     * 
     * Suppose M(initial) is the final number of nodes infected with malware in the
     * entire network, after the spread of malware stops.
     * 
     * We will remove one node from the initial list. Return the node that if
     * removed, would minimize M(initial). If multiple nodes could be removed to
     * minimize M(initial), return such a node with the smallest index.
     * 
     * Note that if a node was removed from the initial list of infected nodes, it
     * may still be infected later as a result of the malware spread.
     * 
     * 
     * 
     * Example 1:
     * 
     * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0
     */  
    //O(MN*4 + K*a(M))/O(2M)
    
    //union find all nodes, then from affected nodes, we collected for each isolated graph,
    //which contains the most nodes, if they have same number of nodes, return the smallest index
    //one
    
    //the difference between II is this is to fix, the node still there, it just stated "remove"
    //from initial list but in graph it is there. which means they just node infected.
    public static int minMalwareSpread2(int[][] g, int[] ini) {
        if (g == null || g.length < 1 || g[0].length < 1 || ini == null || ini.length < 1) return -1;
        
        int r = g.length, c= g[0].length;
        DSU dsu = new DSU(r);
        for(int i = 0; i<r;i++) {
            for(int j =0; j < c;j++) {
                if (g[i][j] == 1) {
                    dsu.union(i, j);
                    int[][] dirs = {{-1,0},{1,0},{0,1},{0,-1}};
                    for(int[] dir: dirs) {
                        int x = i + dir[0];
                        int y = j + dir[1];
                        if (x <r && x>=0 && y<c && y>=0 && g[x][y] == 1) {
                            dsu.union(x,y);
                        }
                    }
                }
            }
        }
        //
        //
        Map<Integer, Integer> map = new HashMap<>();
        for(int inu : ini) {
            int root = dsu.find(inu);
            map.put(root, map.getOrDefault(root,0) + 1);
        }
        //why we choose the min node, because there was only one connect area, and only two nodes
        // so the answer would be min
        
        //also if there are two islands finally but nodes are the same, so we would return the small
        //one
        int delNode = Arrays.stream(ini).min().getAsInt();
        int affectedCnt = Integer.MIN_VALUE;
        for(int nodeId : ini) {
            int root = dsu.find(nodeId);
            if (map.getOrDefault(root,0) > 1) continue;
            int cnt = dsu.size(root);
            if (cnt >affectedCnt || cnt == affectedCnt && nodeId < delNode ) {
                affectedCnt = cnt;
                delNode = nodeId;
            }
        }
        
        return delNode;
        
    }

static class DSU {
    int[] parent;
    int[] size;
    public DSU(int size) {
        this.parent = new int[size];
        this.size = new int[size];
        for(int i =0; i< size;i++) parent[i] = i;
        Arrays.fill(this.size,1);
    }
    
    public int find(int x) {
        while(parent[x] != x) x = parent[x];
        return x;
    }
    
    public void union(int x, int y) {
        x = find(x);
        y = find(y);
        if (size[x] < size[y]) {
            size[y] += size[x];
            parent[x] = y;
        } else {
            size[x] += size[y];
            parent[y] = x;
        }
    }
    
    public int size(int x) {
        x = find(x);
        return size[x];
    }
}
    
    
    
    
    
    
    //DFS 
    public static int minMalwareSpread(int[][] graph, int[] initial) {
        // whole networking visited nodes set
        Set<Integer> visited = new HashSet<>();

        int delNode = Arrays.stream(initial).min().getAsInt();
        // some sub graph, not connected length, like how many nodes
        int subgraphLen = 0;
        for (int i = 0; i < graph.length; i++) {
            if (visited.contains(i)) continue;
            // subgraph visited nodes
            Set<Integer> subVisitedSet = new HashSet<>();
            subVisitedSet.add(i);
            // get all its connected nodes
            collectNodesToSet(subVisitedSet, graph, i);
            int infectedCount = 0;
            int minInfectedNode = Integer.MAX_VALUE;
            for (int iniNodeInFctedId : initial) {
                if (!subVisitedSet.contains(iniNodeInFctedId)) continue;
                infectedCount++;
                minInfectedNode = Math.min(minInfectedNode, iniNodeInFctedId);
            }
            // only process the affected node= 1's group, if there are two 1 group,
            // we want the smaller index one
            if (infectedCount == 1 
                    && (subVisitedSet.size() > subgraphLen 
                         || (subVisitedSet.size() == subgraphLen 
                              && minInfectedNode < delNode))) {
                delNode = minInfectedNode;
                subgraphLen = subVisitedSet.size();
            }
            visited.addAll(subVisitedSet);
        }
        return delNode;
    }

    static void collectNodesToSet(Set<Integer> visited, int[][] graph, int node) {
        int[] adj = graph[node];
        for (int i = 0; i < adj.length; i++) {
            if (i != node && adj[i] == 1 && !visited.contains(i)) {
                visited.add(i);
                collectNodesToSet(visited, graph, i);
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] in = {{1,1,1},{1,1,1},{1,1,1}};
        int[] initial = {0,1};
        System.out.println(minMalwareSpread(in, initial));
    }
}