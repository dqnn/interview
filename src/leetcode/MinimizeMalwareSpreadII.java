package leetcode;
import java.util.*;
public class MinimizeMalwareSpreadII {
    
    /*928. Minimize Malware Spread II
     * (This problem is the same as Minimize Malware Spread, with the differences
     * bolded.)
     * 
     * In a network of nodes, each node i is directly connected to another node j if
     * and only if graph[i][j] = 1.
     * 
     * Some nodes initial are initially infected by malware. Whenever two nodes are
     * directly connected and at least one of those two nodes is infected by
     * malware, both nodes will be infected by malware. This spread of malware will
     * continue until no more nodes can be infected in this manner.
     * 
     * Suppose M(initial) is the final number of nodes infected with malware in the
     * entire network, after the spread of malware stops.
     * 
     * We will remove one node from the initial list, completely removing it and any
     * connections from this node to any other node. Return the node that if
     * removed, would minimize M(initial). If multiple nodes could be removed to
     * minimize M(initial), return such a node with the smallest index.
     * 
     * 
     * 
     * Example 1:
     * 
     * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0
     */
    //this is 
    public static int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length < 1 || graph[0].length < 1 
                || initial == null || initial.length < 1)
            return -1;

        int N = graph.length;
        DSU dsu = new DSU(N);
        Set<Integer> set = new HashSet<>();
        for (int x : initial) set.add(x);
        //this will genreate graphs, if there is no initial nodes in g
        for (int u = 0; u < N; ++u) {
            if (set.contains(u)) continue;
            for (int v = 0; v < N; ++v) {
                if (set.contains(v)) continue;
                if (graph[u][v] == 1) dsu.union(u, v);
            }
        }

        // dsu now represents the components of the graph without
        // any nodes from initial. Let's call this graph G.
        // this count means how many infects nodes in their graph G
        int[] infectedRootCnt = new int[N];
        // store the infected nodes to its connected nodes's root
        Map<Integer, Set<Integer>> nodeToCompo = new HashMap<>();
        // from initial to every node, so if it has another infected node, just
        // ignore it
        // then we add every component its root to components
        // so from count we can know how many components
        for (int u : initial) {
            Set<Integer> infetRoots = new HashSet<>();
            for (int v = 0; v < N; ++v) {
              //adding graph into the set, we need to exclude the 
                //node which is in initial becasue we exclude the nodes when we
                //connect all good nodes
                if (!set.contains(v) && graph[u][v] == 1) {
                    infetRoots.add(dsu.find(v));
                }
            }

            nodeToCompo.put(u, infetRoots);
            for (int c : infetRoots) infectedRootCnt[c]++;
        }

        // For each node u in initial, nodeToCompo.get(u)
        // now has every component from G that u neighbors.

        int res = -1, resNodeCnt = -1;
        for (int u : nodeToCompo.keySet()) {
            Set<Integer> components = nodeToCompo.get(u);
            // score showed how many nodes will this node going to affect
            //
            int curCnt = 0;
            for (int c : components)
             // only check =1 nodes, > 1 means they have 2 infected nodes in 1 graph
                if (infectedRootCnt[c] == 1) curCnt += dsu.size(c);

            if (curCnt > resNodeCnt || curCnt == resNodeCnt && u < res) {
                resNodeCnt = curCnt;
                res = u;
            }
        }

        return res;

    }

    static class DSU {
        int[] parent;
        int[] size;
        public DSU(int size) {
            this.parent = new int[size];
            this.size = new int[size];
            for(int i =0; i< size;i++) parent[i] = i;
            Arrays.fill(this.size,1);
        }
        
        public int find(int x) {
            while(parent[x] != x) x = parent[x];
            return x;
        }
        
        public void union(int x, int y) {
            x = find(x);
            y = find(y);
            if (size[x] < size[y]) {
                size[y] += size[x];
                parent[x] = y;
            } else {
                size[x] += size[y];
                parent[y] = x;
            }
        }
        
        public int size(int x) {
            x = find(x);
            return size[x];
        }
    }

 public static void main(String[] args) {
     int[][] in = {{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}};
     int[] initial = {0,1};
     System.out.println(minMalwareSpread(in, initial));
 }
}